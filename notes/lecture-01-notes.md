# Нотатки спікера — Лекція 1
## Інструментарій Frontend-розробника

---

## Слайд 1: Титульний

Цей курс — про те, як стати Frontend-розробником. Не просто "вивчити HTML", а зрозуміти весь стек інструментів і підхід до роботи в індустрії.

Фронтенд-розробка сьогодні — це серйозна інженерна дисципліна. Тут є свої патерни, інструменти, стандарти якості та командні практики. Саме це ми будемо розбирати протягом курсу.

Курс побудований так: від основ — браузер, інструменти, HTML, CSS, JavaScript — і далі до React і сучасного стека. Кожна тема супроводжується практикою. Важливо не просто слухати, а одразу писати код, пробувати, ламати та розбиратися чому щось не працює.

Перша лекція — про інструменти. Це фундамент: без правильно налаштованого середовища складно рухатися вперед. Розглянемо, що таке фронтенд і чим він відрізняється від дизайну та бекенду, як браузер спілкується з сервером, які редактори та плагіни використовують у реальних командах, і чому без Git на сучасному ринку не обійтись. До кінця заняття буде зрозуміло, як виглядає типовий робочий день розробника і з яких кроків він складається.

---

## Слайд 2: Що таке Frontend?

Зручна аналогія — тіло людини: HTML — це скелет, CSS — шкіра та одяг, JavaScript — м'язи та нервова система. Прибери будь-який шар, і щось перестане працювати: без HTML немає структури, без CSS — немає форми, без JS — немає інтерактивності.

Коли відкривається стрічка фото в Instagram — це фронтенд. Коли натискається лайк, фронтенд відправляє запит до бекенду, який записує дію в базу даних. Все, що відбувається у вікні браузера — відповідальність фронтенд-розробника.

Важлива деталь: фронтенд — це не малювання інтерфейсів. Це складна інженерна робота з продуктивністю, доступністю, безпекою та архітектурою. Сучасний фронтенд-стек — це компілятори, бандлери, системи тестування та CI/CD.

Варто одразу закрити найпоширеніше хибне уявлення: HTML і CSS — це не "несправжнє програмування". Будь-хто, хто спробував побудувати складний адаптивний макет або анімацію без бібліотек, знає, що це потребує чіткого системного мислення.

---

## Слайд 3: Frontend ≠ Дизайн ≠ Backend

Питання "ви займаєтесь дизайном?" виникає часто. Відповідь — ні, це різні спеціальності з різними інструментами та задачами.

Дизайнер отримує технічне завдання, малює макет у Figma, і передає його розробнику. Задача фронтенд-розробника — зробити так, щоб цей макет "ожив" у браузері: коректно відображався на будь-якому екрані, плавно реагував на дії користувача та правильно взаємодіяв з API.

Бекенд-розробник тим часом пише серверну логіку: як зберігати дані, авторизувати користувача, рахувати рекомендації, обробляти платежі.

Фронтенд стоїть рівно між ними. З одного боку — пікселі та анімації, з іншого — запити до API та обробка JSON. Тому хороший фронтенд-розробник розуміє і дизайн-мислення, і серверну архітектуру — хоча б базово.

У великих командах ці ролі чітко розділені. У стартапах або невеликих агентствах одна людина може суміщати дві або навіть всі три ролі — таких називають fullstack-розробниками. Але спеціалізація дає глибину.

---

## Слайд 4: Frontend vs Backend

Зручна аналогія тут — ресторан. Фронтенд-розробник — це офіціант: приймає замовлення від користувача (натискання кнопки), передає його на кухню (бекенд), і приносить результат назад (дані відображаються на екрані).

Кухня може готувати чудові страви, але без офіціанта гість їх не побачить. І навпаки — найкрасивіший зал без кухні нікого не нагодує.

Зверніть увагу на рядок "Швидкість". Чому різні пороги? Браузер — це середовище з затримкою мережі, де користувач безпосередньо відчуває кожні зайві 100 мілісекунд. Сервер у цьому плані знаходиться ближче до даних і може відповідати швидше.

Важлива деталь: JavaScript сьогодні присутній і на фронтенді, і на бекенді — через Node.js. Це один з факторів, чому JS став настільки поширеним: один розробник може писати і клієнтську, і серверну частину однією мовою. Але фронтенд і бекенд — досі різні дисципліни, навіть якщо мова та сама.

---

## Слайд 5: Як браузер спілкується з сервером

Розглянемо на прикладі. Припустимо, потрібно відкрити стрічку новин у соціальній мережі. Що відбувається за лаштунками?

Перший крок — браузер надсилає HTTP GET-запит до сервера: "дай мені головну сторінку". Сервер повертає HTML-файл, браузер його парсить і будує DOM — внутрішнє дерево елементів сторінки.

Далі JavaScript-код на сторінці виконується: він надсилає окремий запит до API — "дай мені свіжі пости для цього користувача". Сервер звертається до бази даних, збирає дані, повертає JSON. Фронтенд отримує цей JSON і оновлює DOM — і ми бачимо стрічку.

Цей ланцюжок відбувається щоразу, коли скролиться сторінка вниз і підвантажуються нові пости. Іноді за одне завантаження сторінки браузер виконує десятки таких запитів паралельно.

Ця схема — основа для розуміння того, як влаштовані сучасні веб-застосунки. Далі в курсі ми будемо детально розбирати кожен її елемент: HTTP-методи, статус-коди, формат JSON, роботу з fetch і async/await.

---

## Слайд 6: Браузери

Chrome — вибір більшості фронтенд-розробників, і на це є причини: найбільш розвинені DevTools, найшвидший V8-рушій, і найширша база користувачів. Якщо сайт працює в Chrome — це вже половина аудиторії.

Але тут є пастка. Safari має власний браузерний рушій WebKit, який трактує деякі CSS-властивості та JavaScript-API інакше. Якщо сайт виглядає ідеально в Chrome, це не гарантує такий же вигляд на iPhone чи MacBook. Баги специфічні для Safari — класика фронтенд-розробки.

Firefox відомий чудовим CSS Debugger: він може відображати grid та flexbox-контейнери наочніше, ніж Chrome. Тому багато верстальників тримають Firefox відкритим поряд.

Edge на базі Chromium — фактично той самий Chrome з іншим інтерфейсом. Але він важливий тим, що вбудований у Windows і є браузером за замовчуванням для мільйонів корпоративних користувачів.

Практичне правило: розробляємо і дебажимо в Chrome, а перед здачею завжди перевіряємо в Safari і Firefox. Якщо є мобільна версія — тестуємо на реальному iPhone, а не тільки через емулятор.

---

## Слайд 7: Chrome DevTools

DevTools — це не просто консоль для виводу помилок. Це повноцінне середовище для дослідження, дебагінгу та оптимізації веб-сторінок. Розробники проводять у DevTools значну частину робочого часу.

Вкладка Elements — найвикористовуваніша. Тут видно DOM-дерево сторінки, застосовані CSS-стилі, обчислені значення властивостей. Можна редагувати стилі прямо в браузері і одразу бачити результат — без перезавантаження, без редактора.

Network — незамінний при роботі з API. Тут видно кожен запит: URL, метод, статус-код, час виконання, тіло запиту та відповіді. Коли щось іде не так між фронтендом і бекендом — відповідь завжди тут.

Device Toolbar дозволяє емулювати різні пристрої та розміри екранів. Перемикнути на iPhone 14 і побачити, як виглядає сайт на мобільному, — секунда роботи. Але пам'ятайте: емулятор не замінює тест на реальному пристрої.

Performance — для профілювання. Якщо сторінка "лагає", тут можна побачити, яка операція займає найбільше часу. Це вже просунута тема, яку будемо розбирати в кінці курсу.

---

## Слайд 8: DevTools — Console на практиці

Відкриємо DevTools і перейдемо на вкладку Console. Пишемо `document.title` і натискаємо Enter. Браузер повертає заголовок поточної сторінки — це і є виконання JavaScript у реальному часі, безпосередньо в контексті завантаженої сторінки.

`console.log` — найпростіший і найпоширеніший спосіб дебагінгу. На початку роботи більшість розробників використовують саме його: вставляємо виклик у потрібному місці коду, виводимо значення змінної, перевіряємо, що функція взагалі викликається. Це простіше, ніж налаштовувати breakpoints, тому `console.log` залишається у практиці навіть досвідчених розробників.

`console.time` і `console.timeEnd` — зручний спосіб виміряти, скільки часу займає операція. Корисно, коли потрібно швидко оцінити продуктивність без профайлера.

`document.querySelectorAll` повертає список всіх елементів, що відповідають CSS-селектору. Запит на кількість посилань на сторінці — чудовий приклад того, як за кілька секунд дослідити структуру чужого сайту, не читаючи його вихідний код.

Console — це і пісочниця для швидких експериментів з JavaScript. Замість того щоб створювати файл і запускати сервер, можна написати і перевірити ідею прямо тут.

---

## Слайд 9: Редактори коду

VS Code — безкоштовний, open-source, і за ним стоїть Microsoft. Оновлення виходять щомісяця, екосистема плагінів налічує тисячі розширень. Саме тому він став стандартом не тільки для фронтенду, але й для бекенду, DevOps та data science.

WebStorm від JetBrains — найрозумніший редактор: він глибше аналізує код, краще підказує при рефакторингу і знаходить помилки, які VS Code може пропустити. Але він платний. Якщо є студентська пошта університету — варто зареєструватися на JetBrains: вони надають безкоштовну ліцензію на весь пакет продуктів для студентів.

Sublime Text — дуже швидкий. Відкриває файли на гігабайти миттєво, де VS Code може підвисати. Деякі розробники тримають його поряд з VS Code саме для роботи з великими логами чи CSV.

Atom — не встановлюйте. GitHub оголосив про закриття проекту у 2022 році. Жодних оновлень безпеки, жодної підтримки. Якщо зустрічаєте туторіали, де рекомендують Atom — вони застарілі.

Для цього курсу — VS Code. Налаштуємо його разом: тема, шрифт, плагіни. Це займе 10 хвилин, але заощадить години в майбутньому.

---

## Слайд 10: VS Code — Обов'язкові плагіни

ESLint — статичний аналізатор коду. Він підкреслює проблеми ще до того, як код запустився: забута змінна, неправильне порівняння, потенційний баг. Це як spell-check, але для логіки програми. Особливо рятує на початку, коли синтаксис ще не доведений до автоматизму.

Prettier вирішує питання форматування раз і назавжди. Відступи, лапки, коми, дужки — все налаштовується один раз і застосовується автоматично при збереженні файлу. У командній роботі це усуває цілий клас суперечок: "де ставити крапку з комою" перестає бути темою для обговорення.

Live Server — локальний веб-сервер з гарячим перезавантаженням. Зберіг файл у редакторі — браузер одразу показав зміни. Без цього плагіна доводилося б кожного разу вручну оновлювати вкладку.

Auto Rename Tag вирішує класичну проблему HTML: змінив відкриваючий тег `<div>` на `<section>` — закриваючий оновився автоматично. Здається дрібниця, але без нього HTML-помилки з незакритими тегами — щоденна реальність.

GitLens додає інформацію про git прямо в редактор: наводиш на рядок — бачиш хто його написав, коли і в якому коміті. Незамінно при роботі в команді.

---

## Слайд 11: VS Code — Ключові скорочення

Розробники, які активно використовують клавіатурні скорочення, працюють помітно швидше — не тому що "клавіші швидші за мишку", а тому що не переривають думку рухом рук між пристроями.

`Ctrl+Shift+P` — Command Palette. Всі команди VS Code доступні через нього: встановити тему, відформатувати документ, запустити задачу. Якщо не пам'ятаєш скорочення — Command Palette знайде потрібне за ключовим словом.

`Ctrl+D` — виділити слово, натиснути ще раз — додається наступне входження. Можна відредагувати всі одразу. Типовий сценарій: треба перейменувати змінну `color` на `colour` в десяти місцях файлу — `Ctrl+D` по колу, і правимо всі одночасно.

`Alt+Click` — мультикурсор. Клікаємо в кількох місцях — пишемо одночасно в усіх. Типовий сценарій: треба додати лапки до десяти значень у масиві — один клік на початок кожного значення, одне натискання `"` — і всі лапки розставлені.

`Alt+↑/↓` — переміщення рядка без вирізання та вставки. Переставити властивості CSS у потрібному порядку займає секунди.

Рекомендую витратити перший тиждень на свідоме тренування цих скорочень — далі вони стануть м'язовою пам'яттю.

---

## Слайд 12: Emmet — суперсила верстальника

Emmet — вбудований у VS Code за замовчуванням, нічого встановлювати не треба. Синтаксис виглядає як CSS-селектори: `>` означає "дочірній елемент", `+` — "сусідній елемент", `*3` — "повторити три рази".

Розглянемо запис `div.container>ul.list>li.item*3` по частинах. `div.container` — це `<div class="container">`. `>ul.list` — всередині нього `<ul class="list">`. `>li.item*3` — і три `<li class="item">` всередині списку. Один рядок → десять рядків готового HTML за одне натискання Tab.

Один з найкорисніших прийомів на практиці — символ `!` в порожньому HTML-файлі. Натискаємо Tab — отримуємо повний HTML5-шаблон: `<!DOCTYPE html>`, `<html>`, `<head>` з charset і viewport, `<body>`. Це стартова точка для кожного нового файлу.

Emmet підтримує також атрибути: `input[type=email]` генерує `<input type="email">`. І нумерацію: `li.item$*5` генерує п'ять елементів з класами `item1`, `item2`... `item5`.

Спочатку синтаксис здається незвичним, але після кількох годин практики руки самі починають писати Emmet-абревіатури замість тегів вручну.

---

## Слайд 13: Emmet — Корисні абревіатури

Спробуємо це в дії. Відкриємо новий файл із розширенням `.html` у VS Code, напишемо `!` і натиснемо Tab. Отримуємо повний HTML5-шаблон за одне натискання — це і є Emmet у найпростішому прояві.

`nav>ul>li*5>a` — класична навігаційна панель: тег `<nav>`, всередині `<ul>`, в ньому п'ять `<li>`, кожен з порожнім `<a>`. Залишається лише заповнити тексти посилань.

`form>input:text+input:email+button` — проста форма реєстрації. Зверніть увагу: `input:text` та `input:email` — це Emmet-скорочення для `<input type="text">` та `<input type="email">`. Emmet знає всі типи інпутів.

`.card>.card__title+.card__body` — BEM-компонент без явного вказання тегів. Якщо тег не вказано, Emmet за замовчуванням генерує `<div>`. Подвійне підкреслення — це патерн BEM (Block Element Modifier), який розбиратимемо детально на лекції про CSS.

Рекомендація: не намагатися вивчити всі абревіатури одразу. Починайте з `!`, `div.class>p` і `ul>li*n`. Решта прийде з практикою.

---

## Слайд 14: Git — машина часу для коду

Уявімо сценарій: три дні роботи, складний компонент написаний з нуля — і раптом випадкове видалення папки або критична помилка, яка ламає все, що було до цього. Без системи контролю версій відновити втрачене неможливо. Git вирішує цю проблему принципово.

Git — це система контролю версій. Кожен коміт — це знімок стану проекту на певний момент часу. Можна сказати: "покажи мені код тижневої давнини" — і Git покаже точно, як виглядав проект у той момент.

Гілки (branches) — ще потужніша функція. Вони дозволяють розробляти нову фічу ізольовано від основного коду. Якщо експеримент не вийшов — гілку просто видаляємо. Основний код не постраждав.

У командній роботі Git стає абсолютно незамінним. Без нього над одним проектом паралельно може працювати лише одна людина — всі інші чекатимуть. З Git — хоч сто розробників одночасно, в окремих гілках, без взаємних перешкод.

І ще одне важливе розмежування, яке часто плутають: Git — це інструмент, що встановлюється локально. GitHub — це хмарний сервіс для зберігання Git-репозиторіїв в інтернеті. Це зовсім різні речі.

---

## Слайд 15: Git — Базовий workflow

Пройдемося по кожній команді — це основний цикл роботи з Git, який повторюється щодня.

`git init` — одноразова команда на початку проекту. Створює прихований каталог `.git`, де зберігається вся історія змін. Після цього папка стає Git-репозиторієм.

`git add .` — команда "підготувати до знімку". Крапка означає "всі змінені файли в поточній папці". Можна вказати конкретний файл: `git add index.html`. Цей крок дає контроль над тим, що потрапить у коміт.

`git commit -m "..."` — власне знімок. Повідомлення описує, що саме змінилось. Через місяць ці повідомлення стануть документацією: "fix: correct email validation" розповідає набагато більше, ніж "changes" або "update".

Префікс `feat:` і `fix:` — частина конвенції Conventional Commits, яку використовують у більшості сучасних команд. `feat` — нова функціональність, `fix` — виправлення помилки.

`git push` — відправка на GitHub. Після цього код існує в хмарі: якщо щось трапиться з локальним комп'ютером, нічого не втрачено.

---

## Слайд 16: Git vs GitHub

Зручна аналогія: Git — це Microsoft Word з увімкненим відстеженням змін. GitHub — це Google Drive, де цей документ зберігається і доступний іншим людям.

Можна використовувати Git без GitHub — просто локально, для особистого проекту. Але без GitHub не вийде отримати переваги хмарного сховища та командної роботи.

Є альтернативи GitHub: GitLab, Bitbucket, Gitea. Принцип той самий — хмарне сховище для Git-репозиторіїв з додатковими інструментами. У великих компаніях часто розгортають власні сервери на базі GitLab.

Окремо варто підкреслити роль GitHub як публічного портфоліо. При перегляді резюме Junior-розробника перше, куди звертаються рекрутери та тімліди — це GitHub-профіль. Якщо там порожньо або є лише кілька закинутих репозиторіїв, це мінус. Якщо є регулярна активність, читабельний код і зрозумілі README — це вже перевага над іншими кандидатами.

Тому починати заповнювати GitHub варто вже зараз, з першого домашнього завдання цього курсу. Нехай там буде навіть просто навчальний проект — головне, що він існує і показує прогрес.

---

## Слайд 17: Як виглядає робочий день Frontend-розробника

Розглянемо типовий робочий день фронтенд-розробника в команді — не абстрактно, а як реальний покроковий процес.

Ранок починається з планування: в Jira або Trello є backlog задач на поточний спринт (зазвичай два тижні). Розробник вибирає задачу, переводить її в статус "In Progress" — і команда бачить, над чим він працює.

Перший крок у коді — нова гілка: `git checkout -b feat/user-profile`. Назва гілки відповідає задачі. Це гарантує, що нова фіча розробляється ізольовано від основного коду.

Далі кодування у VS Code: Live Server відкриває браузер, зміни відображаються в реальному часі. DevTools поряд — перевіряємо верстку, дивимося на мережеві запити, ловимо помилки в консолі.

Перед завершенням — перевірка у кількох браузерах. Хоча б Chrome і Safari, якщо є мобільна версія — і на реальному телефоні.

Pull Request — код виходить на рев'ю до колег. Вони залишають коментарі, можуть запропонувати кращий підхід або вказати на баг. Це не критика, а якість: чотири очі завжди краще двох.

Після затвердження — merge і deploy. Код потрапляє до реальних користувачів. Все — цикл завершено, беремо наступну задачу.

---

## Слайд 18: Домашнє завдання

Усі пункти домашнього завдання розраховані на те, щоб налаштувати середовище до наступної лекції. На наступній парі вже розпочнемо писати HTML, і буде набагато зручніше, якщо VS Code та Git вже встановлені і готові до роботи.

VS Code — безкоштовний, завантажується з офіційного сайту. Встановлення стандартне, без підводних каменів. Плагіни встановлюються через вкладку Extensions зліва — пошук за назвою, кнопка Install.

Реєстрація на GitHub займає кілька хвилин. Варто одразу заповнити профіль: фото, ім'я, коротке bio. Це перший крок до публічного портфоліо.

learngitbranching.js.org — інтерактивна гра, а не документація. Перший розділ ("Main: Introduction Sequence") займає близько 20 хвилин і дає розуміння базових команд та концепції гілок краще, ніж будь-яке відео.

Бонусне завдання: створити репозиторій `hello-frontend` на GitHub, зробити README.md з кількома словами про себе та зафіксувати першим комітом. Хто покаже результат на наступній парі — отримає додатковий бал. Головне тут не результат, а сам процес: перший коміт завжди запам'ятовується.

---

## Слайд 19: Наступна лекція

Наступна лекція — HTML5 і семантична верстка. Здається, це просто: відкриваємо теги, закриваємо теги. Але тут є нюанси, які більшість розробників не усвідомлюють роками.

Розберемо, чому не можна просто ліпити `div` скрізь, і як правильна семантика впливає на три речі одразу: SEO (пошукові системи краще розуміють зміст сторінки), доступність (скрін-рідери для людей з вадами зору орієнтуються на семантику) та підтримку коду (колеги одразу розуміють, що це `<header>`, а не безіменний `<div>`).

Також розглянемо атрибути, форми, медіа-елементи та базову структуру HTML5-документа. До наступної пари варто пройти туторіал по Git і встановити VS Code — тоді зможемо одразу писати код, а не витрачати час на налаштування.
