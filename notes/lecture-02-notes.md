# Нотатки до лекції 2: Основи HTML. Структура документа

---

## 1. Вступ
Минулого разу ми говорили про інструменти — VS Code, Git, DevTools. 

Сьогодні вперше відкриваємо редактор і пишемо реальний код. Тема здається простою, але в HTML є нюанси, які більшість розробників-початківців ігнорують роками — і потім розплачуються проблемами з SEO, доступністю і підтримкою коду. 

Мета сьогоднішньої лекції — не просто познайомитися з тегами, а зрозуміти логіку мови: чому вона влаштована саме так і що відбувається "під капотом" у браузері, коли він зустрічає HTML-файл.

---

## 2. Що таке HTML?
Важливо одразу розставити крапки над «і»: HTML — це не мова програмування. У ній немає умов, немає циклів, немає функцій. Це мова розмітки — вона описує, яку структуру має документ. Браузер читає цей опис і будує відповідне дерево елементів на екрані.

Тім Бернерс-Лі винайшов HTML у 1991 році, щоб вчені в CERN могли ділитися документами через мережу. Перша версія мала лише 18 тегів. Зараз у HTML5 їх більше 100 — і кожен з'явився з конкретної потреби.

HTML5 — це не просто "п'ята версія", а живий стандарт, який постійно розвивається. Специфікацію підтримує WHATWG — консорціум з представників Google, Apple, Mozilla та Microsoft. Нові можливості додаються поступово, без різких "версій".

Аналогія: HTML — це каркас будинку. Без цегли і штукатурки (CSS) він виглядає як будівельні ліси. Без електрики і водопроводу (JavaScript) в ньому не комфортно жити. Але без каркасу — нема чого стилізувати і нема куди підключати логіку.

---

## 3. Як браузер читає HTML
Розглянемо на прикладі. Припустимо, браузер отримує HTML-файл. Він починає читати його зверху вниз, символ за символом. Коли зустрічає відкриваючий тег — додає вузол до дерева. Коли зустрічає закриваючий — піднімається рівнем вище. Так поступово будується DOM-дерево — ієрархічна структура всіх елементів сторінки.

Цікавий нюанс: браузер не кидає помилку, якщо HTML написаний з помилками. Замість цього він намагається виправити розмітку сам, керуючись специфікацією. Забули закрити `<p>`? Браузер закриє його автоматично перед наступним блоковим елементом. Написали тег великими літерами? Нічого страшного — HTML регістронезалежний.

Але це подвійне лезо: ваша сторінка може "виглядати нормально" у браузері навіть з битим HTML. А потім виявитися, що різні браузери по-різному "виправили" ваші помилки — і сторінка виглядає інакше в Safari чи Firefox. Тому варто завжди писати валідний HTML і перевіряти через validator.w3.org.

---

## 4. Анатомія HTML-документа
Розберемо кожен рядок — це скелет, який буде присутній у кожному HTML-файлі.

Перший рядок — `<!DOCTYPE html>` — це не тег. Це директива браузеру: "рендери цю сторінку у стандартному режимі HTML5". Якщо забути цей рядок, деякі браузери перемикаються у "quirks mode" — режим сумісності зі старими сторінками 1990-х, де CSS і JavaScript поводяться непередбачувано.

`<html lang="uk">` — кореневий елемент всього документа. Атрибут `lang` говорить браузеру, скрінрідерам і пошуковикам, якою мовою написана сторінка. Для України — `uk`, для англійської — `en`.

`<head>` — невидима частина документа. Тут живуть метадані: кодування, заголовок вкладки, підключення CSS, SEO-теги. Нічого з `<head>` не відображається безпосередньо на сторінці.

`<body>` — все, що бачить користувач. Весь видимий вміст — тут.

Зверніть увагу на відступи: кожен вкладений елемент зсунутий на два пробіли. Це не обов'язково для браузера, але критично для читабельності коду.

---

## 5. Елемент <head>: що всередині
Зупинимося на двох найважливіших метатегах, які починківці часто ігнорують.

`<meta charset="UTF-8">` — без нього кирилиця може відображатися кракозябрами. UTF-8 підтримує всі мови світу, включно з emoji. Ставимо цей тег завжди і завжди першим, ще до `<title>` — бо браузер починає декодувати сторінку до того, як дочитує весь head.

`<meta name="viewport">` — критично важливий для мобільних пристроїв. Без нього мобільний браузер робить так: уявляє, що ширина екрану — 980 пікселів (як у десктопу), рендерить сторінку на цій ширині, а потім зменшує її, щоб помістити в реальний екран телефону. Результат — дрібний нечитабельний текст і незручна навігація. З цим тегом браузер використовує реальну ширину пристрою.

`<title>` — це не просто назва вкладки. Google показує його як заголовок у результатах пошуку. Від нього залежатиме CTR (клікабельність посилання). Хороший title: коротко, конкретно, з ключовим словом. Поганий title: "Home Page" або "Без назви".

---

## 6. Атрибути елементів
Атрибути — це спосіб передати додаткову інформацію тегу. 

Синтаксис завжди однаковий: `ім'я="значення"`. 

Але є виняток — булеві атрибути. Їх достатньо просто написати, без значення: `disabled`, `required`, `checked`, `readonly`. Сама присутність атрибуту означає "true", відсутність — "false". Можна написати `disabled="disabled"` або просто `disabled` — результат однаковий.

Важливо розуміти різницю між атрибутами `id` і `class`. 

`id` — унікальний ідентифікатор, один на всю сторінку. Якщо зробити два елементи з однаковим id — HTML буде невалідним, хоча браузер і "проковтне" це. `class` — навпаки, може повторюватися будь-яку кількість разів, і один елемент може мати кілька класів через пробіл.

Лапки навколо значень атрибутів — технічно необов'язкові, якщо значення без пробілів. Але завжди використовуйте їх — це хороша практика і вимога валідатора.

---

## 7. Текстові теги
Зупинимося на частій помилці: різниця між `<strong>` і `<b>`, між `<em>` і `<i>`. Візуально вони однакові — жирний і курсивний текст. Але семантика різна.

`<b>` і `<i>` — суто візуальні теги без змісту. "Зроби жирним", "зроби курсивом". `<strong>` означає "цей текст важливий". `<em>` означає "на цьому слові наголос у реченні". Скрінрідер, читаючи `<strong>`, змінить інтонацію або наголосить на слові голосом. `<b>` він прочитає так само, як звичайний текст.

Приклад: "Натисніть кнопку Зберегти" — тут `<strong>` доречний, бо це критична інструкція. "Текст жирним шрифтом для декорації" — тут `<b>`.

`<br>` — часто зловживають. Якщо між абзацами потрібен простір — це CSS, а не `<br>`. Використовуйте `<br>` тільки там, де перенос рядка є частиною контенту: адреса, вірш, код з багаторядковим виводом.

---

## 8. Ієрархія заголовків
Ієрархія заголовків — це зміст книги. Уявіть підручник: є назва книги (`<h1>`), розділи (`<h2>`), підрозділи (`<h3>`), параграфи (`<h4>`). Якщо зміст побудований логічно — читач розуміє структуру одним поглядом. Те саме з HTML.

Пошукові системи використовують заголовки, щоб зрозуміти, про що сторінка. Google надає найбільшу вагу `<h1>` при ранжуванні. Якщо `<h1>` містить ключове слово — сторінка краще ранжується за цим запитом.

Скрінрідер для незрячих може перестрибувати між заголовками — це його навігація по сторінці. Якщо заголовки пропущені (`<h2>` → `<h4>`), навігація ламається.

Типова помилка: розробник ставить `<h3>` замість `<h2>`, бо `<h3>` менший за розміром. Це неправильно. Розмір шрифту визначається через CSS — `font-size`. Заголовок обирається виходячи з ієрархії контенту, а не з бажаного розміру тексту. 

---

## 9. Блокові vs Рядкові елементи
Це одна з фундаментальних концепцій HTML, яку необхідно зрозуміти до того, як братися за CSS. Всі HTML-елементи ведуть себе одним із двох способів.

Блокові елементи — як цеглини стіни. Кожна займає всю ширину контейнера і стоїть на своєму рядку. Після параграфа `<p>` наступний елемент починається з нового рядка — автоматично, без жодного CSS.

Рядкові елементи — як слова в тексті. Вони течуть у рядку разом з іншим вмістом, займають рівно стільки місця, скільки їм потрібно. Кілька `<span>` поспіль стоять поруч, не переходячи на новий рядок.

Важлива заборона: рядковий елемент не може містити блоковий. Класична помилка початківця — покласти `<p>` всередину `<a>`. Браузер "виправить" це, але поведінка буде непередбачуваною.

Пізніше, на уроці про CSS, ми дізнаємося, що цю поведінку можна змінити через властивість `display`. Але за замовчуванням саме так.

---

## 10. <div> і <span> — контейнери без семантики
`<div>` і `<span>` — особливі теги: вони нічого не означають самі по собі. Жодної семантики, жодного стилю за замовчуванням (ну, крім того що div — блоковий, а span — рядковий).

Їх призначення — бути контейнерами для групування елементів з метою подальшої стилізації через CSS або маніпуляцій через JavaScript.

Класичний сценарій: є блок "картка товару" — заголовок, опис, ціна, кнопка. Їх потрібно обернути в один контейнер, щоб задати спільний фон, відступи, тінь. Для цього і служить `<div>`.

На наступній лекції ми познайомимося з семантичними альтернативами: `<article>`, `<section>`, `<nav>`, `<header>`. Вони роблять те саме, що й `<div>`, але несуть змістове навантаження — браузер, пошуковик і скрінрідер розуміють, що цей блок означає. Правило просте: якщо є відповідний семантичний тег — використовуй його, а не `<div>`.

---

## 11. Списки
Два типи списків — і між ними є змістова різниця, яку варто розуміти.

`<ul>` — unordered list, невпорядкований. Порядок пунктів не має значення. Підходить для: навігаційне меню, список інгредієнтів, перелік функцій продукту. Якщо переставити пункти місцями — смисл не зміниться.

`<ol>` — ordered list, впорядкований. Порядок важливий. Підходить для: кроки інструкції, рецепт, топ-10, алгоритм. Якщо переставити — сенс порушиться.

`<li>` — list item, єдиний дозволений прямий нащадок `<ul>` та `<ol>`. Всередину `<li>` можна класти будь-який вміст, у тому числі ще один список — так отримуємо вкладені списки для ієрархічних структур.

Поширена помилка: ставити `<li>` без батьківського `<ul>` або `<ol>`. HTML-валідатор це позначить як помилку. Ще одна: класти блокові елементи безпосередньо в `<ul>` — тільки `<li>` є допустимим прямим нащадком.

---

## 12. Коли <ul>, коли <ol>?
Просте правило вибору між `<ul>` і `<ol>`: поставте собі питання — якщо переставити пункти місцями, зміниться смисл? Якщо так — `<ol>`. Якщо ні — `<ul>`.

Для навігаційного меню порядок пунктів формально не критичний — можна "Контакти" поставити першим або останнім, навігація залишиться навігацією. Тому `<ul>`.

Для кроків встановлення програмного забезпечення порядок абсолютно критичний — спочатку встановити Node.js, потім зробити npm install, а не навпаки. Тому `<ol>`.

Це не просто стилістичне питання — `<ol>` автоматично нумерує елементи (можна кастомізувати через CSS властивість `list-style-type`), а пошуковики можуть використовувати впорядковані списки для rich snippets в результатах пошуку — той блок з кроками "Як зробити...", який іноді з'являється прямо в Google.

---

## 13. Гіперпосилання <a>
Тег `<a>` — один з найпотужніших і найдавніших в HTML. Власне, "HyperText" в назві мови — це про посилання.

Розберемо різницю між абсолютним і відносним шляхом. Абсолютний — повна адреса з протоколом: `https://example.com/about`. Відносний — шлях відносно поточного файлу: `about.html` або `../images/photo.jpg`. Для внутрішньої навігації по сайту — завжди відносні шляхи. Вони коротші і не зламаються, якщо сайт переїде на інший домен.

Атрибут `target="_blank"` відкриває посилання в новій вкладці. Але завжди додавайте поруч `rel="noopener noreferrer"`. Без цього відкрита сторінка має доступ до вашої через `window.opener` — потенційна дірка в безпеці, яку використовують для фішингу.

Якірні посилання `#id` — зручний спосіб навігації по довгій сторінці. Клік на посилання `href="#contacts"` прокрутить сторінку до елемента з `id="contacts"`. Саме так працюють кнопки "Перейти до розділу" на лендингах.

---

## 14. Абсолютні vs Відносні шляхи
Розберемо на конкретній структурі проекту. Усі файли рано чи пізно треба посилатися між собою — HTML на CSS, HTML на зображення, сторінки одна на одну.

Відносний шлях будується так: беремо поточний файл як відправну точку. Якщо потрібний файл в тій же папці — просто ім'я файлу. Якщо в підпапці — ім'я папки через слеш. Якщо потрібно піднятися на рівень вище — `../`.

`../` — це "вийди з поточної папки". Якщо ми у `css/style.css` і хочемо звернутися до `images/logo.png`, шлях буде `../images/logo.png`: спочатку виходимо з папки `css`, потім заходимо в `images`.

Типова помилка початківців: скопіювати абсолютний шлях з файлової системи — `C:\Users\User\projects\site\images\logo.png`. На сервері такий шлях, звичайно, не спрацює. Завжди використовуйте відносні шляхи для файлів всередині проекту.

---

## 15. Зображення <img>
`<img>` — самозакриваючий тег: у нього немає закриваючого тега і немає вмісту. Лише атрибути.

Два обов'язкових атрибути: `src` і `alt`. `src` — шлях до файлу зображення. `alt` — альтернативний текст.

Навіщо `alt`? По-перше, якщо зображення не завантажилося (повільний інтернет, неправильний шлях, сервер недоступний) — користувач побачить текстовий опис і зрозуміє, що там мало бути. По-друге, скрінрідери для незрячих зачитують `alt` вголос — без нього користувач не знає, що за зображення на сторінці. По-третє, пошуковики не "бачать" зображення — вони читають `alt`, щоб зрозуміти вміст.

Важлива деталь: для декоративних зображень, які не несуть смислового навантаження, `alt` пишемо порожнім: `alt=""`. Це сигнал скрінрідеру: "пропусти це зображення". Але атрибут має бути присутній — його відсутність означає "скрінрідер, вгадуй сам", і він спробує зачитати ім'я файлу.

Атрибути `width` і `height` рекомендується вказувати: браузер резервує місце для зображення ще до його завантаження, і сторінка не "стрибає" при завантаженні.

---

## 16. Формати зображень для вебу
Вибір формату безпосередньо впливає на швидкість завантаження сторінки — а швидкість впливає на позиції в Google і відсоток відмов.

JPEG — найкращий для фотографій. Алгоритм стиснення відкидає деталі, які людське око не розрізняє добре: дрібні переходи кольору у складних сценах. Але для зображень з чіткими межами (текст, скріншоти) він дає артефакти — "квадратики" навколо гострих країв.

PNG — без втрат якості і підтримує прозорість (alpha-канал). Ідеальний для логотипів з прозорим фоном, скріншотів, зображень з текстом. Але розмір файлу більший.

SVG — не растр, а математичний опис форм. Може масштабуватися до будь-якого розміру без втрати якості. Логотип компанії як SVG виглядає однаково чітко і на телефоні Retina, і на великому моніторі 4K.

WebP — сучасний компромісний формат від Google. Підтримується всіма сучасними браузерами. Дає файли на 25–35% менші ніж JPEG при тій самій якості. Рекомендую як основний формат для фотографій на нових проектах.

---

## 17. Перший HTML-документ: live-розбір
Розберемо цей документ рядок за рядком — він використовує все, що ми вивчили сьогодні.

Рядок 1: `<!DOCTYPE html>` — без коментарів, обов'язково.

Рядок 2: `<html lang="uk">` — вказуємо мову, щоб браузери і скрінрідери знали, якою мовою читати.

Рядки 3–7: блок `<head>`. Charset іде першим. Viewport — щоб сторінка коректно відображалась на мобільних. Title — буде у вкладці браузера і в результатах Google.

Рядок 8: відкриваємо `<body>` — тут починається видимий контент.

Рядок 9: `<h1>` — єдиний на сторінці. Ім'я людини як назва сторінки.

Рядок 10: `<p>` з `<strong>` всередині — рядковий елемент всередині блокового, що є правильним.

Рядки 11–15: заголовок розділу `<h2>` і список навичок.

Рядок 16: `<a href="mailto:...">` — клік відкриє поштовий клієнт.

Цей документ вже можна відкрити в браузері — він буде без стилів, але структурно правильним. А потім підключимо CSS і все стане красивішим.

---

## 18. Типові помилки початківців
Ці помилки зустрічаються у 90% перших проектів студентів. Розберемо найважливіші.

Відсутній `charset` — це кракозябри замість кирилиці. Особливо болісно, коли сторінка "виглядає нормально" у вас, бо ваш браузер підібрав правильне кодування, а в іншому браузері або на іншій ОС — символи розсипаються.

Кілька `<h1>`  — Google і скрінрідери очікують один головний заголовок. Кілька h1 плутають пошуковик і погіршують SEO.

Незакриті теги — браузер виправляє сам, але може виправити не так, як ви очікуєте. Наприклад, незакритий `<div>` може "поглинути" наступні елементи і поламати CSS-стилізацію.

Абсолютний шлях до файлу на диску — класика. Сторніка відкривається у вас локально, ви здаєте роботу, викладач відкриває на своєму комп'ютері — зображення не видно, бо шляху `C:\Users\Іванов\...` на його машині не існує.

validator.w3.org — безкоштовний офіційний валідатор HTML від W3C. Вставляєте URL або HTML-код і отримуєте список помилок. Корисна звичка — валідувати код перед здачею роботи.

---

## 19. Домашнє завдання
Завдання прив'язане до лабораторної роботи № 2 з плану курсу.

Головна мета — не просто написати HTML, а зробити це правильно: один h1, логічна ієрархія заголовків, атрибут alt у зображень, валідний DOCTYPE. Перевірка через validator.w3.org є обов'язковою частиною — нуль помилок.

Структура CV довільна, але має містити: ім'я і посаду, короткий опис, список навичок, список інтересів або проектів, контактну інформацію з посиланням-mailto. Стилізація CSS поки не потрібна — вона буде після лекції 6. Наразі важлива правильна структура.

Фінальний крок — закомітити файли в GitHub. Повторна практика з минулої лекції: `git init`, `git add .`, `git commit -m "feat: add html cv"`, `git push`. Хто покаже мені посилання на GitHub-репозиторій — отримає бонусний бал. Назва репозиторію: `html-cv`.

---

## 20. Наступна лекція
Наступна лекція — семантична розмітка HTML5. Ми вже знаємо `<div>` і `<span>` — нейтральні контейнери. Але HTML5 пропонує десятки тегів з конкретним змістом: `<header>`, `<nav>`, `<main>`, `<article>`, `<section>`, `<footer>`. Вони роблять те саме, що і div — групують елементи — але розповідають браузеру, пошуковику і скрінрідеру, що саме знаходиться в цьому блоці.

Правильна семантика безпосередньо впливає на позиції в Google і на доступність сайту для людей з обмеженими можливостями. Це не теорія — це практичний інструмент, який відрізняє хорошого верстальника від посереднього. До зустрічі!
